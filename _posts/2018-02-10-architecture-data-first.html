---
layout: post
title: "Data-First Architecture - Asset Management Case Study"
tags: [functional,architecture,data]
description: "Data-First Architecture - Asset Management Case Study"
keywords: functional, architecture, data
excludeme: true
---
<p>I recently had a light bulb moment while read a <a href="https://twitter.com/etodd_/status/936587511580844032">tweet</a> from Evan Todd.
It helped bring together some ideas I've had for a while on software architecture.</p>
<p>Data shape should dictate...
First thing you should do is estimate size.</p>
<p>Funtional programming really helps with this mindset. In FP we keep the data and functions separate. We do this because data is simple and pure functions are simple.</p>
<p>I'm going to make the case with an example from my industry. I will argue most asset management systems store and use the wrong data. This limits the functionality and increases the complexity of these systems.</p>
<h2>Case Study - Asset Management Systems</h2>
<p>Asset management systems what is the data?</p>
<h2>Ideas</h2>
<p>This is v important and FP encourages it. I have a good example in finance that I'm considering blogging in the new year. #fsharp</p>
<p>basically the data without behaviour should dictate the architecture of the system. Then pure functions complete the picture.</p>
<p>To wrap up: think about the actual problem and the data it needs. Then write functions to manage that data. Don't think about classes and interfaces and closures and reflection and RAII and exceptions and polymorphism and who knows what else.</p>
<p>This philosophy is called data-oriented design, by the way. For those interested, here are some videos!</p>
<p>Premature micro-optimization is wasteful. Yet this waste is utterly insignificant compared to implementing algorithms with non-viable complexity.
In this specific case, you aren't gonna need YAGNIâ€”complexity analysis matters, even in the very first version you write.</p>
<p>Exactly, also need to upfront estimate the size of data worst case. Infinitely scalable by default leads to bad perf + complexity.</p>
<p>It is interesting. I'm definitely going to blog about this. My case study is asset management systems. Almost all get the data wrong. They think the data is positions and p&amp;l. It bloats them and limits functionality.</p>
<h2>Conclusion</h2>
<p>Can't find any description of this apart from the gaming industry.</p>
<p>In the days of cloud computing where architectural costs are more obvious right sizing the architecture to the data is more important.</p>
<p>Most articles titled architecture jump straight in to some feature of the codebase.</p>


