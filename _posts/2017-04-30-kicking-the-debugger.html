---
layout: post
title: "Kicking the Debugger habit"
tags: [debugger,debugging,bugs]
description: "How to kick the step through debugging habit"
keywords: f#, fsharp, debugger, debugging, bugs
---
<p>This post covers my experience of giving up breakpoint and step-through debugging.</p>
<h3>My Domain</h3>
<p>There are some interesting features of the domain I work in that have led me here.
Financial analytics tends to compose many algorithms such as curve fitting, statistics, monte carlo and optimisation.
The public API on the other hand is very simple: given this portfolio return the risks associated.</p>
<p>A bug report is more likely to be 'this risk number looks a little odd' rather than 'an exception was thrown and here is the stack trace'.
I can't agree with the idea that you should only unit test your public APIs.
For me this should be: you need to unit test your public APIs but if your domain is sufficiently complex you also need to unit test internal modules.
The key is if a bug report comes in that queries an API result how quickly could you investigate and resolve any possible issue.</p>
<h3>What's wrong with debugging?</h3>
<p>For areas I work on:</p>
<ul>
<li>It's not scalable - for larger code paths setting break points and stepping through is just not feasible. It's like finding a needle in a haystack.</li>
<li>It's limited in power - even mature debugging frameworks such as in Visual Studio are limited in the kind of conditional logic you can use while debugging.</li>
<li>It's time consuming - many a good hour can be spent pressing F5/F10/F11 in a zombie like state only to restart and try again.</li>
</ul>
<h3>What's the alternative?</h3>
<p>Since starting to use <a href="https://github.com/haf/expecto">Expecto</a> I've been using the command line to run unit tests.
<a href="https://github.com/haf/expecto">Expecto</a> does integrate with visual studio and can even do live unit testing.
I've just found using a set of commands I've built up in FAKE to be more flexible and productive e.g.</p>
<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l">1: </span>
<span class="l">2: </span>
<span class="l">3: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="fsharp">    <span class="i">test</span> <span class="i">integration</span>
    <span class="i">test</span> <span class="i">all</span>
    <span class="i">test</span> <span class="n">64</span> <span class="i">debug</span> <span class="o">--</span><span class="i">stress</span> <span class="n">2</span>
</code></pre></td>
</tr>
</table>
<p><a href="https://github.com/haf/expecto">Expecto</a> encourages using normal code for organisation, setup &amp; teardown and parameterisation of tests instead of a limited framework of attribute coding.</p>
<p>I've applied this idea to debugging. I have a debug module in the core of my codebase that is conditional on the debug configuration.
I can annotate code with validation and some debug output.
The command line records a history of the test results and validation output.
Once complete compiling in release ensures all this diagnostic code is completely removed.</p>
<p>This started out as simple functions to <code>printfn</code> data being sequenced and piped but expanded into functions to count calls, check for NaNs globally, serialize function inputs and outputs, test convergence of numbers etc.
This is normal code and there is huge scope for adding conditional logic.</p>
<h3>Conclusion</h3>
<p>For me kicking the debugger habit has been a productivity boost.
It forces me to think more logically about how I validate and break down a problem.</p>
<p>It reduces the complexity of my tooling.
Finding and fixing bugs feels more like coding and unit testing.
I can use a simpler code editor plus the command line.</p>
<p>The result is I now have more confidence that once I've created the initial unit test I will be able to resolve it quickly.</p>


