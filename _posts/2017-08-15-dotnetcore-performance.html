---
layout: post
title: ".Net Core 2.0 vs Java - Performance Notes"
tags: [dotnetcore,java,performance,benchmarks]
description: "Benchmarks Game C# .Net Core 2.0 vs Java Performance Notes"
keywords: C#, F#, dotnetcore, java, performance, benchmarks
---
<p>Over the past few weeks I've been submitting improvements to some of the C# programs in the <a href="http://benchmarksgame.alioth.debian.org/">Benchmarks Game</a>.</p>
<p>When I first saw the <a href="http://benchmarksgame.alioth.debian.org/u64q/csharp.html">C# .Net Core vs Java</a> benchmarks the score was <strong>.Net Core 2.0 4</strong> - <strong>Java 6</strong>.
This surprised me as I was under the impression .Net Core 2.0 performance would be very good.</p>
<p>I have concentrated on the 6 programs where Java was faster and not looked at the other 4 (binary-trees, spectral-norm, fasta, pidigits).</p>
<p>Below are some notes on each of these programs and some caveated conclusions.</p>
<h3>reverse-complement</h3>
<p>Old Result: C# 1.39s - Java 1.10s</p>
<p>Changes made: Reversing in place and more efficient parallel processing.</p>
<p>New Result: C# 0.79s - Java 1.10s</p>
<h3>mandelbrot</h3>
<p>Old Result: C# 7.29s - Java 7.10s</p>
<p>Changes made: Simplified the parallel processing by using TPL Parallel.For.</p>
<p>New Result: C# 6.78s - Java 7.10s</p>
<h3>n-body</h3>
<p>Old Result: C# 21.71s - Java 21.54s</p>
<p>I made many failed attempts to try to improve this result e.g. low level parallel, SMD.</p>
<p>Dissapointing as it looks like Java has a small edge on these single thread numeric calculations.</p>
<p>Some I submitted can be found <a href="https://alioth.debian.org/tracker/index.php?group_id=100815&amp;atid=413122">here</a>.</p>
<h3>fannkuch-redux</h3>
<p>Old Result: C# 18.80s - Java 13.74s</p>
<p>I think Java must have some advantage in small int array manipulation.</p>
<p>I tried splitting up into more parallel blocks but the overhead outways the better CPU use.</p>
<p>Change mades: Small array optimisations and more efficient parallel processing.</p>
<p>New Result: C# 14.98s - Java 13.74s</p>
<h3>k-nucleotide</h3>
<p>Old Result: C# 13.76s - Java 07.93s</p>
<p>Java code cheats and has a very bespoke dictionary from an obscure lib.</p>
<p>The dictionary count is done in parallel but I think the bespoke Java dictionary wins here.</p>
<p>Change mades: More efficient byte array memory use and parallel processing.</p>
<p>New Result: C# 12.37s - Java 07.93s</p>
<h3>regex-redux</h3>
<p>Old Result: C# 32.02s - Java 12.31s</p>
<p>Regex is not good in .Net. I don't think its even compiled on .Net Core.</p>
<p>Change mades: Reordered the tasks to run longest to shortest.</p>
<p>New Result: C# 31.19s - Java 12.31s</p>
<h2>Conclusion</h2>
<p>I found the <a href="http://benchmarksgame.alioth.debian.org/">Benchmarks Game</a> to be a very good set of benchmarks.
The benchmarks are well thought through and cover classic single thread calculations to multi threaded IO data processing.
Obviously areas such as network performance are not as easy to test in this kind of game.
The orgainisers are tough but fair and the rules make a lot of sense.
The site is efficiently run and overnight was updated to .Net Core 2.0 RTM.</p>
<p>So now the score is <strong>.Net Core 2.0 6</strong> - <strong>Java 4</strong>.
My overall impression is that .Net Core 2.0 and Java have similar performance with Java maybe having a small edge on calculations and are manipulation and .Net having better parallel libraries.</p>
<p>So now I am out of ideas on how to improve these further.  If you have any ideas or questions feel to get in touch.</p>


